<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Plasma Wall - Join the green thesis</title>
<script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="min-h-screen text-white overflow-hidden relative" style="background: linear-gradient(135deg, #000000, #0a1f0a, #001100, #0a1f0a, #000000);">

<!-- Enhanced Green Cosmic Background -->
<div class="absolute inset-0 overflow-hidden">
    <!-- Main energy portal with intense green focus -->
    <div class="energy-portal absolute inset-0 flex items-center justify-center">
        <div class="portal-ring-outer"></div>
        <div class="portal-ring-main"></div>
        <div class="portal-ring-inner"></div>
        <div class="portal-core"></div>
    </div>
    
    <!-- Green energy field -->
    <div class="green-energy-field absolute inset-0"></div>
    
    <!-- Floating green plasma orbs -->
    <div class="green-plasma-orbs absolute inset-0">
        <div class="green-orb orb-1"></div>
        <div class="green-orb orb-2"></div>
        <div class="green-orb orb-3"></div>
        <div class="green-orb orb-4"></div>
        <div class="green-orb orb-5"></div>
        <div class="green-orb orb-6"></div>
        <div class="green-orb orb-7"></div>
        <div class="green-orb orb-8"></div>
    </div>
    
    <!-- Green matrix grid -->
    <div class="green-matrix-grid absolute inset-0"></div>
</div>

<!-- Audio -->
<audio id="bgMusic" loop preload="auto" style="display: none;">
    <source src="./interstellar.mp3" type="audio/mpeg">
    <source src="./interstellar.wav" type="audio/wav">
    <source src="./music.mp3" type="audio/mpeg">
</audio>

<!-- Enhanced Header -->
<header class="relative z-10 text-center py-8">
    <h1 class="text-6xl font-bold text-white mb-4 green-cyber-glow animate-green-pulse">
        PLASMA HALL OF FAME 🕊
    </h1>
    <p class="text-2xl text-green-300 font-bold green-matrix-text">
        Submit your X handle. Join the Stablecoin supercycle 🕊
    </p>
    <div class="mt-4 text-lg text-green-400 green-pulse-fade" id="liveCounter">
        Initializing quantum matrix...🕊
    </div>
</header>

<!-- Enhanced Input Section -->
<div class="relative z-10 flex flex-col items-center justify-center px-4 mb-8">
    <!-- Main Input Section -->
    <div class="green-input-matrix flex items-center gap-4 max-w-4xl w-full">
        <div class="green-input-wrapper flex-1 relative">
            <input 
                type="text" 
                id="usernameInput" 
                placeholder="Enter X handle..." 
                class="w-full px-8 py-6 rounded-2xl text-white bg-black/80 border-3 border-green-500 focus:outline-none focus:border-green-300 focus:ring-4 focus:ring-green-400/40 text-xl backdrop-blur-xl green-cyber-input transition-all duration-500"
            >
            <div class="green-input-glow absolute inset-0 rounded-2xl opacity-0 transition-opacity duration-500"></div>
        </div>
        <button 
            id="submitBtn" 
            class="px-12 py-6 bg-gradient-to-r from-green-600 via-green-500 to-green-400 hover:from-green-500 hover:via-green-400 hover:to-green-300 rounded-2xl font-bold text-xl green-cyber-button transform hover:scale-110 transition-all duration-500 shadow-2xl min-w-[140px]"
        >
            <span class="relative z-10">INJECT</span>
        </button>
    </div>
    
    <!-- Search Results Counter -->
    <div id="searchResults" class="mt-4 text-center text-green-300 green-search-counter opacity-0 transition-opacity duration-500">
    </div>
    
    <div class="flex gap-6 mt-8">
        <button 
            id="musicToggle" 
            class="px-8 py-4 bg-gradient-to-r from-green-800 to-green-600 hover:from-green-600 hover:to-green-400 rounded-xl font-bold transition-all duration-300 green-cyber-button-small text-lg"
        >
            🎵 Audio Matrix
        </button>
        <button 
            id="syncBtn" 
            class="px-8 py-4 bg-gradient-to-r from-green-700 to-green-500 hover:from-green-500 hover:to-green-300 rounded-xl font-bold transition-all duration-300 green-cyber-button-small text-lg"
        >
            🔄 Quantum Sync
        </button>
    </div>
    
    <div id="connectionStatus" class="mt-6 text-center text-green-300 green-status-text text-lg">
        Quantum matrix ready for consciousness injection...🕊
    </div>
</div>

<!-- Enhanced Plasma Wall Container -->
<div class="relative z-10 px-4 pb-8">
    <div class="green-plasma-container bg-black/70 backdrop-blur-2xl rounded-3xl p-10 border-3 border-green-500/50 max-w-full mx-auto overflow-hidden shadow-2xl">
        <div id="userCount" class="text-center text-green-200 mb-10 text-2xl font-bold green-cyber-text">
            Scanning neural network...
        </div>
        
        <!-- Enhanced Moving Wall -->
        <div class="green-plasma-wall-container relative h-[500px] overflow-hidden rounded-3xl border-2 border-green-500/30">
            <div id="movingWall" class="green-plasma-wall absolute top-0 left-0 flex items-center gap-8 py-8"></div>
        </div>
        
        <div class="flex justify-between items-center mt-8 text-lg">
            <div class="text-green-400 green-matrix-signature">
                Neural Network: <span class="text-green-300 font-bold">ACTIVE</span>
            </div>
            <div class="text-green-400">
                Architect: <span class="text-green-300 font-bold">@aabis</span>
            </div>
        </div>
    </div>
</div>

<!-- Enhanced Green Cyberpunk Styles -->
<style>
/* Enhanced Green Color Palette */
:root {
    --neon-green: #00ff41;
    --bright-green: #22ff55;
    --matrix-green: #00cc33;
    --dark-green: #006622;
    --deep-green: #003311;
    --cyber-black: #000000;
}

/* Enhanced Background Effects with Green Focus */
.energy-portal {
    pointer-events: none;
}

.portal-ring-outer {
    width: 800px;
    height: 800px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    border: 4px solid transparent;
    border-radius: 50%;
    background: conic-gradient(
        from 0deg,
        transparent 0deg,
        var(--neon-green) 8deg,
        var(--bright-green) 12deg,
        transparent 20deg,
        transparent 80deg,
        var(--matrix-green) 88deg,
        var(--neon-green) 92deg,
        transparent 100deg
    );
    animation: portalSpinSlow 20s linear infinite;
    opacity: 0.6;
    mask: radial-gradient(circle, transparent 45%, white 48%, white 55%, transparent 58%);
    filter: drop-shadow(0 0 30px var(--neon-green));
}

.portal-ring-main {
    width: 500px;
    height: 500px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    border: 3px solid transparent;
    border-radius: 50%;
    background: conic-gradient(
        from 180deg,
        transparent 0deg,
        var(--bright-green) 20deg,
        var(--neon-green) 40deg,
        transparent 60deg,
        var(--matrix-green) 180deg,
        var(--bright-green) 200deg,
        transparent 220deg,
        transparent 320deg,
        var(--neon-green) 340deg,
        transparent 360deg
    );
    animation: portalSpinMedium 12s linear infinite reverse;
    opacity: 0.8;
    mask: radial-gradient(circle, transparent 30%, white 35%, white 68%, transparent 72%);
    filter: drop-shadow(0 0 20px var(--bright-green));
}

.portal-ring-inner {
    width: 250px;
    height: 250px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    border: 3px solid var(--neon-green);
    border-radius: 50%;
    animation: portalSpinFast 6s linear infinite;
    box-shadow: 
        0 0 40px var(--neon-green),
        inset 0 0 20px var(--bright-green);
    opacity: 0.9;
}

.portal-core {
    width: 80px;
    height: 80px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: radial-gradient(circle, var(--neon-green), var(--bright-green), transparent);
    border-radius: 50%;
    animation: coreGlow 3s ease-in-out infinite;
    filter: blur(2px);
}

@keyframes portalSpinSlow { from { transform: translate(-50%, -50%) rotate(0deg); } to { transform: translate(-50%, -50%) rotate(360deg); } }
@keyframes portalSpinMedium { from { transform: translate(-50%, -50%) rotate(360deg); } to { transform: translate(-50%, -50%) rotate(0deg); } }
@keyframes portalSpinFast { from { transform: translate(-50%, -50%) rotate(0deg); } to { transform: translate(-50%, -50%) rotate(360deg); } }
@keyframes coreGlow {
    0%, 100% { opacity: 0.6; transform: translate(-50%, -50%) scale(1); }
    50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
}

/* Green Energy Field */
.green-energy-field {
    background: 
        radial-gradient(circle at 15% 25%, rgba(0, 255, 65, 0.2) 0%, transparent 50%),
        radial-gradient(circle at 85% 75%, rgba(34, 255, 85, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 50% 50%, rgba(0, 204, 51, 0.1) 0%, transparent 70%),
        radial-gradient(circle at 25% 85%, rgba(0, 255, 65, 0.12) 0%, transparent 60%),
        radial-gradient(circle at 75% 15%, rgba(34, 255, 85, 0.08) 0%, transparent 40%);
    animation: greenEnergyPulse 8s ease-in-out infinite;
}

@keyframes greenEnergyPulse {
    0%, 100% { opacity: 0.8; transform: scale(1); }
    33% { opacity: 1; transform: scale(1.02); }
    66% { opacity: 0.9; transform: scale(0.98); }
}

/* Enhanced Green Plasma Orbs */
.green-plasma-orbs {
    pointer-events: none;
}

.green-orb {
    position: absolute;
    border-radius: 50%;
    background: radial-gradient(circle, var(--neon-green), var(--bright-green), rgba(0, 255, 65, 0.4), transparent);
    filter: blur(1.5px);
    animation: greenPlasmaDrift 12s ease-in-out infinite;
    box-shadow: 0 0 20px var(--neon-green);
}

.orb-1 { width: 35px; height: 35px; top: 10%; left: 8%; animation-delay: 0s; }
.orb-2 { width: 28px; height: 28px; top: 20%; right: 12%; animation-delay: -2s; }
.orb-3 { width: 42px; height: 42px; bottom: 20%; left: 15%; animation-delay: -4s; }
.orb-4 { width: 25px; height: 25px; top: 65%; right: 20%; animation-delay: -6s; }
.orb-5 { width: 38px; height: 38px; bottom: 35%; right: 8%; animation-delay: -8s; }
.orb-6 { width: 32px; height: 32px; top: 45%; left: 3%; animation-delay: -10s; }
.orb-7 { width: 30px; height: 30px; top: 75%; left: 50%; animation-delay: -12s; }
.orb-8 { width: 26px; height: 26px; top: 30%; left: 70%; animation-delay: -14s; }

@keyframes greenPlasmaDrift {
    0%, 100% { transform: translate(0, 0) scale(1); opacity: 0.7; }
    25% { transform: translate(40px, -50px) scale(1.3); opacity: 1; }
    50% { transform: translate(-30px, -90px) scale(0.7); opacity: 0.8; }
    75% { transform: translate(-50px, 40px) scale(1.1); opacity: 0.9; }
}

/* Enhanced Green Matrix Grid */
.green-matrix-grid {
    background-image: 
        linear-gradient(var(--neon-green) 2px, transparent 2px),
        linear-gradient(90deg, var(--neon-green) 2px, transparent 2px);
    background-size: 100px 100px;
    animation: greenGridFlow 25s linear infinite;
    opacity: 0.15;
}

@keyframes greenGridFlow {
    0% { transform: translate(0, 0); }
    100% { transform: translate(100px, 100px); }
}

/* Enhanced Green Typography */
.green-cyber-glow {
    text-shadow: 
        0 0 10px var(--neon-green),
        0 0 20px var(--neon-green),
        0 0 30px var(--bright-green),
        0 0 40px var(--matrix-green);
    color: #ffffff;
}

@keyframes green-pulse {
    0%, 100% { 
        text-shadow: 
            0 0 10px var(--neon-green),
            0 0 20px var(--neon-green),
            0 0 30px var(--bright-green);
    }
    50% { 
        text-shadow: 
            0 0 20px var(--neon-green),
            0 0 40px var(--neon-green),
            0 0 60px var(--bright-green),
            0 0 80px var(--matrix-green);
    }
}

.animate-green-pulse {
    animation: green-pulse 2.5s ease-in-out infinite;
}

.green-matrix-text {
    font-family: 'Courier New', monospace;
    text-shadow: 0 0 15px var(--bright-green);
}

.green-pulse-fade {
    animation: greenPulseFade 2.5s ease-in-out infinite;
    font-family: 'Courier New', monospace;
}

@keyframes greenPulseFade {
    0%, 100% { opacity: 0.7; transform: scale(1); }
    50% { opacity: 1; transform: scale(1.02); }
}

/* Enhanced Green Input Styling */
.green-input-matrix {
    animation: greenSlideInMatrix 1.2s ease-out;
    position: relative;
    z-index: 20;
}

@keyframes greenSlideInMatrix {
    from { transform: translateY(-40px); opacity: 0; filter: blur(10px); }
    to { transform: translateY(0); opacity: 1; filter: blur(0px); }
}

.green-input-wrapper {
    position: relative;
    z-index: 21;
}

.green-cyber-input {
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(0, 20, 0, 0.95));
    box-shadow: 
        inset 0 0 30px rgba(0, 255, 65, 0.15),
        0 0 30px rgba(0, 255, 65, 0.2),
        0 0 60px rgba(0, 255, 65, 0.1);
    font-family: 'Courier New', monospace;
    position: relative;
    z-index: 22;
    border-width: 3px;
}

.green-cyber-input:focus + .green-input-glow {
    opacity: 1;
    background: linear-gradient(135deg, rgba(0, 255, 65, 0.15), rgba(34, 255, 85, 0.1), transparent);
    box-shadow: 0 0 40px rgba(0, 255, 65, 0.3);
}

.green-cyber-button {
    background: linear-gradient(135deg, var(--matrix-green), var(--bright-green), var(--neon-green));
    box-shadow: 
        0 0 30px rgba(0, 255, 65, 0.4),
        inset 0 0 20px rgba(0, 255, 65, 0.15),
        0 8px 32px rgba(0, 255, 65, 0.3);
    text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
    position: relative;
    overflow: hidden;
    z-index: 21;
    border: 2px solid var(--neon-green);
}

.green-cyber-button::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
    animation: greenButtonShine 2.5s ease-in-out infinite;
}

@keyframes greenButtonShine {
    0% { left: -100%; }
    100% { left: 100%; }
}

.green-cyber-button-small {
    background: linear-gradient(135deg, var(--dark-green), var(--matrix-green), var(--bright-green));
    box-shadow: 
        0 0 20px rgba(0, 255, 65, 0.3),
        inset 0 0 15px rgba(0, 255, 65, 0.1);
    position: relative;
    z-index: 21;
    border: 2px solid var(--matrix-green);
}

.green-search-counter {
    font-family: 'Courier New', monospace;
    text-shadow: 0 0 12px var(--bright-green);
    font-size: 18px;
    font-weight: bold;
}

/* Enhanced Green Wall Container */
.green-plasma-container {
    animation: greenContainerRise 1.8s ease-out;
    box-shadow: 
        0 0 80px rgba(0, 255, 65, 0.15),
        inset 0 0 40px rgba(0, 255, 65, 0.08),
        0 20px 60px rgba(0, 255, 65, 0.1);
    border-width: 3px;
}

@keyframes greenContainerRise {
    from { transform: translateY(60px); opacity: 0; filter: blur(15px); }
    to { transform: translateY(0); opacity: 1; filter: blur(0px); }
}

/* Enhanced Green Plasma Wall */
.green-plasma-wall-container {
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(0, 255, 65, 0.03), rgba(0, 0, 0, 0.9));
    mask: linear-gradient(90deg, transparent 0%, black 8%, black 92%, transparent 100%);
    -webkit-mask: linear-gradient(90deg, transparent 0%, black 8%, black 92%, transparent 100%);
    box-shadow: inset 0 0 50px rgba(0, 255, 65, 0.1);
}

.green-plasma-wall {
    width: max-content;
    animation: greenPlasmaFlow 45s linear infinite;
    padding: 30px 0;
}

@keyframes greenPlasmaFlow {
    from { transform: translateX(0); }
    to { transform: translateX(-50%); }
}

/* Enhanced Green Avatar Cards */
.green-avatar-card {
    flex-shrink: 0;
    width: 160px;
    height: 160px;
    position: relative;
    transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    animation: greenCardMaterialize 1s ease-out;
    filter: drop-shadow(0 0 15px rgba(0, 255, 65, 0.4));
}

.green-search-highlight {
    filter: drop-shadow(0 0 25px rgba(34, 255, 85, 1)) !important;
    animation: greenSearchPulse 1.8s ease-in-out infinite !important;
}

@keyframes greenSearchPulse {
    0%, 100% { 
        filter: drop-shadow(0 0 25px rgba(34, 255, 85, 1));
        transform: scale(1);
    }
    50% { 
        filter: drop-shadow(0 0 40px rgba(0, 255, 65, 1));
        transform: scale(1.08);
    }
}

@keyframes greenCardMaterialize {
    from { 
        transform: scale(0.2) rotate(20deg); 
        opacity: 0;
        filter: blur(15px);
    }
    to { 
        transform: scale(1) rotate(0deg); 
        opacity: 1;
        filter: blur(0px);
    }
}

.green-avatar-card:hover {
    transform: scale(1.2) translateY(-20px) rotate(5deg);
    z-index: 20;
    filter: drop-shadow(0 0 35px rgba(0, 255, 65, 0.8));
}

.green-search-highlight:hover {
    filter: drop-shadow(0 0 50px rgba(0, 255, 65, 1)) !important;
}

.green-avatar-img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 25px;
    border: 4px solid var(--matrix-green);
    box-shadow: 
        0 0 40px rgba(0, 255, 65, 0.5),
        inset 0 0 25px rgba(0, 255, 65, 0.15);
    transition: all 0.5s ease;
    background: linear-gradient(135deg, var(--deep-green), var(--matrix-green), var(--dark-green));
}

.green-search-highlight .green-avatar-img {
    border-color: var(--bright-green) !important;
    box-shadow: 
        0 0 40px rgba(34, 255, 85, 0.8),
        inset 0 0 25px rgba(34, 255, 85, 0.2) !important;
}

.green-avatar-card:hover .green-avatar-img {
    border-color: var(--neon-green);
    box-shadow: 
        0 0 50px rgba(0, 255, 65, 0.9),
        inset 0 0 35px rgba(0, 255, 65, 0.25);
    filter: brightness(1.3) contrast(1.2) saturate(1.2);
}

.green-handle-display {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(0, 255, 65, 0.25), rgba(0, 0, 0, 0.95));
    color: var(--neon-green);
    text-align: center;
    padding: 10px 6px;
    font-size: 13px;
    font-weight: bold;
    border-radius: 0 0 21px 21px;
    border: 3px solid var(--matrix-green);
    border-top: none;
    backdrop-filter: blur(15px);
    transition: all 0.4s ease;
    text-shadow: 0 0 8px rgba(0, 255, 65, 0.9);
    font-family: 'Courier New', monospace;
}

.green-search-highlight .green-handle-display {
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(34, 255, 85, 0.3), rgba(0, 0, 0, 0.95)) !important;
    border-color: var(--bright-green) !important;
    color: var(--bright-green) !important;
    text-shadow: 0 0 10px rgba(34, 255, 85, 0.9) !important;
}

.green-avatar-card:hover .green-handle-display {
    background: linear-gradient(135deg, var(--neon-green), var(--bright-green), var(--neon-green));
    color: var(--cyber-black);
    text-shadow: 0 0 8px rgba(0, 0, 0, 0.9);
    transform: translateY(-6px);
    box-shadow: 0 6px 20px rgba(0, 255, 65, 0.6);
}

.green-search-highlight:hover .green-handle-display {
    background: linear-gradient(135deg, var(--bright-green), var(--neon-green), var(--bright-green)) !important;
    color: var(--cyber-black) !important;
    text-shadow: 0 0 8px rgba(0, 0, 0, 0.9) !important;
    box-shadow: 0 6px 20px rgba(34, 255, 85, 0.8) !important;
}

/* Enhanced Loading States */
.green-loading-matrix {
    background: linear-gradient(
        45deg, 
        rgba(0, 0, 0, 0.9) 25%, 
        rgba(0, 255, 65, 0.3) 50%, 
        rgba(0, 0, 0, 0.9) 75%
    );
    background-size: 400% 400%;
    animation: greenMatrixShimmer 1.8s ease-in-out infinite;
    border-radius: 25px;
    border: 4px solid var(--matrix-green);
    position: relative;
    overflow: hidden;
    box-shadow: 0 0 30px rgba(0, 255, 65, 0.4);
}

.green-loading-matrix::before {
    content: '⟡';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 40px;
    color: var(--neon-green);
    animation: greenLoadingSpin 1.2s linear infinite;
    text-shadow: 0 0 15px var(--neon-green);
}

@keyframes greenMatrixShimmer {
    0%, 100% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
}

@keyframes greenLoadingSpin {
    from { transform: translate(-50%, -50%) rotate(0deg); }
    to { transform: translate(-50%, -50%) rotate(360deg); }
}

.green-error-matrix {
    background: linear-gradient(135deg, var(--matrix-green), var(--bright-green), var(--neon-green));
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--cyber-black);
    font-size: 40px;
    font-weight: bold;
    border-radius: 25px;
    border: 4px solid var(--neon-green);
    animation: greenErrorPulse 2s ease-in-out infinite;
    text-shadow: 0 0 8px rgba(0, 0, 0, 0.8);
    box-shadow: 0 0 40px rgba(0, 255, 65, 0.6);
}

@keyframes greenErrorPulse {
    0%, 100% { 
        box-shadow: 0 0 40px rgba(0, 255, 65, 0.6);
        transform: scale(1);
    }
    50% { 
        box-shadow: 0 0 60px rgba(0, 255, 65, 0.9);
        transform: scale(1.05);
    }
}

/* Enhanced Status Styling */
.green-status-text {
    font-family: 'Courier New', monospace;
    text-shadow: 0 0 12px var(--matrix-green);
    font-weight: bold;
}

.green-cyber-text {
    font-family: 'Courier New', monospace;
    text-shadow: 0 0 15px var(--neon-green);
    animation: greenTextGlow 3s ease-in-out infinite;
}

@keyframes greenTextGlow {
    0%, 100% { text-shadow: 0 0 15px var(--neon-green); }
    50% { text-shadow: 0 0 25px var(--bright-green); }
}

.green-matrix-signature {
    font-family: 'Courier New', monospace;
    font-size: 14px;
    opacity: 0.9;
    text-shadow: 0 0 8px var(--matrix-green);
}

/* Responsive Design */
@media (max-width: 768px) {
    .green-input-matrix {
        flex-direction: column;
        gap: 20px;
    }
    
    .green-input-wrapper {
        width: 100%;
    }
    
    .green-avatar-card {
        width: 140px;
        height: 140px;
    }
    
    .portal-ring-outer {
        width: 500px;
        height: 500px;
    }
    
    .portal-ring-main {
        width: 350px;
        height: 350px;
    }
    
    h1 {
        font-size: 3xl;
    }
}
</style>

<!-- Enhanced JavaScript with Fixed Backend Communication -->
<script>
// Enhanced Configuration with better backend handling
const CONFIG = {
    // Your backend URL
    SERVER_URL: 'http://162.250.191.81:4000',
    // Backup CORS proxies for cross-origin requests
    PROXY_URLS: [
        'https://api.allorigins.win/get?url=',
        'https://corsproxy.io/?',
        'https://cors-anywhere.herokuapp.com/'
    ],
    TIMEOUT: 10000,
    MAX_RETRIES: 3,
    RETRY_DELAY: 1500
};

// In-memory storage for this session (no localStorage dependency)
let quantumUsers = [];
let lastSyncTime = 0;

// DOM elements
const usernameInput = document.getElementById('usernameInput');
const searchResults = document.getElementById('searchResults');
const submitBtn = document.getElementById('submitBtn');
const syncBtn = document.getElementById('syncBtn');
const movingWall = document.getElementById('movingWall');
const bgMusic = document.getElementById('bgMusic');
const musicToggle = document.getElementById('musicToggle');
const connectionStatus = document.getElementById('connectionStatus');
const userCount = document.getElementById('userCount');
const liveCounter = document.getElementById('liveCounter');

let musicPlaying = false;
let syncInProgress = false;
let currentSearchTerm = '';
let filteredUsers = [];
let isSearchMode = false;
let backendConnected = false;

// Enhanced default users including your requested ones
const DEFAULT_USERS = [
    'proofofnathan', 'scene999', 'MaxApoz', 'shadowofthefax',
    'primay_eth', 'kolyposts', 'techaddictif', 'CATTtwit', 
    'The9bo', 'ImFaziiii', 'aabis'
];

let allUsers = [...DEFAULT_USERS];

// Enhanced music functionality
musicToggle.addEventListener('click', async () => {
    try {
        if (musicPlaying) { 
            bgMusic.pause(); 
            musicToggle.textContent = '🎵 Audio Matrix'; 
            musicPlaying = false; 
            console.log('🔇 Audio matrix deactivated');
        } else { 
            bgMusic.volume = 0.4;
            await bgMusic.play(); 
            musicToggle.textContent = '🔇 Mute Matrix'; 
            musicPlaying = true; 
            console.log('🎵 Audio matrix activated');
        }
    } catch(e) { 
        console.error('❌ Audio matrix error:', e);
        updateStatus('⚠️ Audio matrix offline', 'warning');
    }
});

// Enhanced sync functionality
syncBtn.addEventListener('click', async () => {
    if (syncInProgress) return;
    
    syncInProgress = true;
    syncBtn.disabled = true;
    syncBtn.innerHTML = '🔄 Syncing...';
    syncBtn.style.transform = 'scale(0.95)';
    
    updateStatus('🔄 Force synchronizing with quantum backend...', 'info');
    
    const success = await loadFromBackend(true);
    
    setTimeout(() => {
        syncBtn.disabled = false;
        syncBtn.innerHTML = '🔄 Quantum Sync';
        syncBtn.style.transform = 'scale(1)';
        syncInProgress = false;
        
        if (success) {
            updateStatus('✅ Quantum sync complete - backend online', 'success');
        } else {
            updateStatus('⚠️ Backend unreachable - using local cache', 'warning');
        }
    }, 2000);
});

// Enhanced status update function
function updateStatus(message, type = 'info') {
    connectionStatus.textContent = message;
    connectionStatus.className = `mt-6 text-center green-status-text text-lg ${
        type === 'success' ? 'text-green-300' :
        type === 'warning' ? 'text-yellow-400' :
        type === 'error' ? 'text-red-400' :
        'text-green-300'
    }`;
    
    setTimeout(() => {
        if (connectionStatus.textContent === message) {
            const statusText = backendConnected ? 
                'Quantum backend synchronized - ready for injection' : 
                'Local quantum matrix ready - backend offline';
            connectionStatus.textContent = statusText;
            connectionStatus.className = 'mt-6 text-center green-status-text text-lg text-green-300';
        }
    }, 6000);
}

// Enhanced avatar loading system with better profile picture fetching
function createAvatarCard(username) {
    console.log(`🖼️ Materializing neural avatar for: ${username}`);
    
    const card = document.createElement('div');
    card.className = 'green-avatar-card';
    
    const img = document.createElement('img');
    img.className = 'green-avatar-img green-loading-matrix';
    img.alt = username;
    
    const overlay = document.createElement('div');
    overlay.className = 'green-handle-display';
    overlay.textContent = `@${username}`;
    
    card.appendChild(img);
    card.appendChild(overlay);
    
    // Enhanced avatar sources prioritizing Twitter/X and better services
    const avatarSources = [
        // Primary Twitter/X sources (highest priority)
        `https://unavatar.io/twitter/${username}`,
        `https://unavatar.io/x/${username}`,
        
        // GitHub (many Twitter users have same handle)
        `https://avatars.githubusercontent.com/${username}?size=160`,
        `https://github.com/${username}.png?size=160`,
        
        // Multi-platform services
        `https://unavatar.io/${username}`,
        
        // Enhanced generated avatars with cyberpunk green theme
        `https://api.dicebear.com/7.x/adventurer/png?seed=${username}&size=160&backgroundColor=00ff41,22ff55,00cc33&randomizeIds=true`,
        `https://api.dicebear.com/7.x/personas/png?seed=${username}&size=160&backgroundColor=00ff41,22ff55,00cc33&randomizeIds=true`,
        `https://api.dicebear.com/7.x/bottts/png?seed=${username}&size=160&backgroundColor=00ff41,22ff55&randomizeIds=true`,
        `https://api.dicebear.com/7.x/avataaars/png?seed=${username}&size=160&backgroundColor=00ff41,22ff55,00cc33&randomizeIds=true`,
        
        // Robohash with cyberpunk sets
        `https://robohash.org/${username}?size=160x160&set=set1&bgset=bg2`,
        `https://robohash.org/${username}?size=160x160&set=set2&bgset=bg1`,
        `https://robohash.org/${username}?size=160x160&set=set3&bgset=bg2`,
        
        // UI Avatars with green matrix styling
        `https://ui-avatars.com/api/?name=${username.slice(0,2).toUpperCase()}&background=00ff41&color=000000&size=160&bold=true&rounded=true&font-size=0.4`,
        `https://ui-avatars.com/api/?name=${username.charAt(0).toUpperCase()}&background=22ff55&color=000000&size=160&bold=true&rounded=true&font-size=0.5`,
    ];
    
    let sourceIndex = 0;
    let attempts = 0;
    const maxAttempts = avatarSources.length;
    let loadStartTime = Date.now();
    
    const tryNextSource = () => {
        if (attempts >= maxAttempts) {
            console.log(`❌ All ${maxAttempts} avatar sources failed for ${username}, creating matrix avatar`);
            card.removeChild(img);
            const matrixDiv = document.createElement('div');
            matrixDiv.className = 'green-error-matrix';
            matrixDiv.style.width = '100%';
            matrixDiv.style.height = '100%';
            matrixDiv.textContent = username.slice(0,2).toUpperCase();
            card.insertBefore(matrixDiv, overlay);
            return;
        }
        
        const currentSource = avatarSources[sourceIndex];
        const sourceType = currentSource.includes('twitter') || currentSource.includes('/x/') ? 'Twitter/X' :
                          currentSource.includes('github') ? 'GitHub' :
                          currentSource.includes('dicebear') ? 'Generated' :
                          currentSource.includes('robohash') ? 'Robot' :
                          currentSource.includes('ui-avatars') ? 'Letter' : 'Other';
        
        console.log(`  📡 Neural probe ${attempts + 1}/${maxAttempts} for ${username}: ${sourceType}`);
        
        const timeout = setTimeout(() => {
            console.log(`  ⏰ Neural timeout for ${username} on ${sourceType}`);
            attempts++;
            sourceIndex = (sourceIndex + 1) % avatarSources.length;
            tryNextSource();
        }, 5000);
        
        const onSuccess = () => {
            clearTimeout(timeout);
            const loadTime = Date.now() - loadStartTime;
            img.classList.remove('green-loading-matrix');
            console.log(`  ✅ AVATAR LOADED: ${username} via ${sourceType} (${loadTime}ms)`);
            
            // Add success animation
            card.style.animation = 'greenCardMaterialize 0.8s ease-out';
        };
        
        const onError = () => {
            clearTimeout(timeout);
            console.log(`  ❌ Neural probe failed: ${sourceType} for ${username}`);
            attempts++;
            sourceIndex = (sourceIndex + 1) % avatarSources.length;
            tryNextSource();
        };
        
        // Enhanced image loading with comprehensive validation
        img.onload = () => {
            if (img.naturalWidth > 10 && img.naturalHeight > 10 && 
                img.naturalWidth !== 1 && img.naturalHeight !== 1 &&
                !img.src.includes('placeholder') && !img.src.includes('default')) {
                onSuccess();
            } else {
                console.log(`  ⚠️ Invalid/placeholder image for ${username}: ${img.naturalWidth}x${img.naturalHeight}`);
                onError();
            }
        };
        
        img.onerror = onError;
        
        // Add cache-busting for better loading
        const cacheBuster = Math.random().toString(36).substring(7);
        img.src = `${currentSource}${currentSource.includes('?') ? '&' : '?'}v=${cacheBuster}`;
    };
    
    // Start loading with delay for better UX
    setTimeout(() => tryNextSource(), Math.random() * 200);
    return card;
}

// Enhanced display function with better animations
function displayPlasmaWall(usersToDisplay = null) {
    const displayUsers = usersToDisplay || allUsers;
    console.log('🌌 Materializing plasma wall with', displayUsers.length, 'neural entities');
    
    // Clear wall with fade effect
    movingWall.style.opacity = '0.5';
    setTimeout(() => {
        movingWall.innerHTML = '';
        movingWall.style.opacity = '1';
        
        // Create cards with enhanced quantum timing
        displayUsers.forEach((username, index) => {
            setTimeout(() => {
                const card = createAvatarCard(username);
                card.style.animationDelay = `${index * 0.1}s`;
                // Add search highlight if searching
                if (currentSearchTerm && username.toLowerCase().includes(currentSearchTerm.toLowerCase())) {
                    card.classList.add('green-search-highlight');
                }
                movingWall.appendChild(card);
            }, index * 80);
        });
        
        // Duplicate for seamless loop
        setTimeout(() => {
            displayUsers.forEach((username, index) => {
                setTimeout(() => {
                    const card = createAvatarCard(username);
                    card.style.animationDelay = `${(displayUsers.length + index) * 0.1}s`;
                    if (currentSearchTerm && username.toLowerCase().includes(currentSearchTerm.toLowerCase())) {
                        card.classList.add('green-search-highlight');
                    }
                    movingWall.appendChild(card);
                }, index * 60);
            });
        }, displayUsers.length * 80 + 800);
    }, 300);
    
    // Update counters with enhanced styling
    if (currentSearchTerm) {
        userCount.textContent = `${displayUsers.length} of ${allUsers.length} Neural Entities Found`;
        liveCounter.textContent = `🔍 Search Results: ${displayUsers.length} matches for "${currentSearchTerm}" 🕊`;
    } else {
        userCount.textContent = `${allUsers.length} Neural Entities in Quantum Matrix`;
        liveCounter.textContent = `⚡ Quantum Network: ${allUsers.length} consciousness signatures active 🕊`;
    }
}

// Enhanced search functionality
function performSearch(searchTerm) {
    currentSearchTerm = searchTerm.trim();
    
    if (!currentSearchTerm) {
        // No search term, show all users
        isSearchMode = false;
        filteredUsers = [];
        searchResults.style.opacity = '0';
        submitBtn.innerHTML = '<span class="relative z-10">INJECT</span>';
        usernameInput.placeholder = "Enter X handle...";
        displayPlasmaWall();
        return;
    }
    
    // Enable search mode
    isSearchMode = true;
    submitBtn.innerHTML = '<span class="relative z-10">🔍 SEARCH</span>';
    
    // Enhanced filtering
    filteredUsers = allUsers.filter(username => 
        username.toLowerCase().includes(currentSearchTerm.toLowerCase())
    );
    
    // Update search results counter with better styling
    const resultCount = filteredUsers.length;
    if (resultCount === 0) {
        searchResults.textContent = `❌ No neural signatures found for "${currentSearchTerm}"`;
        searchResults.className = 'mt-4 text-center text-red-400 green-search-counter opacity-100 transition-opacity duration-500';
    } else {
        searchResults.textContent = `✅ ${resultCount} neural signature${resultCount === 1 ? '' : 's'} found for "${currentSearchTerm}"`;
        searchResults.className = 'mt-4 text-center text-green-300 green-search-counter opacity-100 transition-opacity duration-500';
    }
    
    searchResults.style.opacity = '1';
    displayPlasmaWall(filteredUsers);
}

// Enhanced user submission with better error handling
async function submitUser(username) {
    const cleanUsername = username.replace('@', '').replace(/[^a-zA-Z0-9_]/g, '');
    
    // If in search mode, just perform search
    if (isSearchMode || currentSearchTerm) {
        performSearch(username);
        return;
    }
    
    // Validation
    if (!cleanUsername || cleanUsername.length < 2) {
        alert('⚠️ Neural signature invalid - minimum 2 characters required');
        return;
    }
    
    if (cleanUsername.length > 30) {
        alert('⚠️ Neural signature too long - maximum 30 characters');
        return;
    }
    
    if (allUsers.includes(cleanUsername)) {
        alert('⚡ Consciousness already exists in the quantum matrix!');
        usernameInput.value = '';
        return;
    }
    
    console.log('🧬 Processing neural injection:', cleanUsername);
    
    // Enhanced submit animation
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<span class="relative z-10">⟡ INJECTING...</span>';
    submitBtn.style.transform = 'scale(0.95)';
    submitBtn.style.background = 'linear-gradient(135deg, #00ff41, #22ff55)';
    updateStatus('🧬 Injecting consciousness into quantum matrix...', 'info');
    
    // Add user immediately for instant feedback
    allUsers.push(cleanUsername);
    quantumUsers.push(cleanUsername);
    displayPlasmaWall();
    
    // Try to save to backend
    const backendSuccess = await saveToBackend(cleanUsername);
    
    // Update status based on result
    if (backendSuccess) {
        updateStatus('✅ Consciousness successfully injected into quantum backend!', 'success');
        backendConnected = true;
    } else {
        updateStatus('✅ Consciousness injected locally - backend sync pending', 'warning');
    }
    
    // Clear input with smooth animation
    usernameInput.style.transform = 'scale(0.95)';
    setTimeout(() => {
        usernameInput.value = '';
        usernameInput.style.transform = 'scale(1)';
    }, 300);
    
    // Reset button after delay
    setTimeout(resetSubmitButton, 3000);
    
    console.log('✨ Neural injection complete - consciousness integrated');
}

// Enhanced backend save with better error handling and CORS handling
async function saveToBackend(username) {
    console.log('🚀 Initiating quantum save protocol for:', username);
    
    const saveData = { username: username, timestamp: Date.now() };
    
    // Strategy 1: Direct connection
    try {
        console.log('  🔄 Attempting direct backend connection...');
        const response = await fetch(`${CONFIG.SERVER_URL}/users`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
                'Access-Control-Allow-Origin': '*'
            },
            body: JSON.stringify(saveData),
            mode: 'cors',
            signal: AbortSignal.timeout(CONFIG.TIMEOUT)
        });
        
        if (response.ok) {
            const result = await response.json();
            console.log('✅ Direct quantum save successful:', result);
            return true;
        } else {
            console.log(`❌ Direct save failed: ${response.status} ${response.statusText}`);
        }
    } catch (error) {
        console.log('❌ Direct connection failed:', error.message);
    }
    
    // Strategy 2: CORS proxy attempts
    for (let i = 0; i < CONFIG.PROXY_URLS.length; i++) {
        try {
            console.log(`  🔄 Attempting proxy ${i + 1}...`);
            const proxyUrl = CONFIG.PROXY_URLS[i];
            const targetUrl = `${CONFIG.SERVER_URL}/users`;
            
            let fetchUrl, fetchOptions;
            
            if (proxyUrl.includes('allorigins')) {
                fetchUrl = `${proxyUrl}${encodeURIComponent(targetUrl)}`;
                fetchOptions = {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ method: 'POST', body: JSON.stringify(saveData) }),
                    signal: AbortSignal.timeout(CONFIG.TIMEOUT)
                };
            } else {
                fetchUrl = `${proxyUrl}${targetUrl}`;
                fetchOptions = {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(saveData),
                    signal: AbortSignal.timeout(CONFIG.TIMEOUT)
                };
            }
            
            const response = await fetch(fetchUrl, fetchOptions);
            
            if (response.ok) {
                console.log(`✅ Proxy quantum save successful via proxy ${i + 1}`);
                return true;
            } else {
                console.log(`❌ Proxy ${i + 1} failed: ${response.status}`);
            }
        } catch (error) {
            console.log(`❌ Proxy ${i + 1} error:`, error.message);
        }
    }
    
    console.error('❌ All quantum save strategies failed - storing locally only');
    return false;
}

// Enhanced backend loading with better CORS handling
async function loadFromBackend(forceSync = false) {
    console.log('📡 Initiating quantum network scan...', forceSync ? '(FORCED)' : '');
    
    // Strategy 1: Direct connection
    try {
        console.log('  🔄 Attempting direct backend load...');
        const response = await fetch(`${CONFIG.SERVER_URL}/users`, {
            method: 'GET',
            headers: { 
                'Accept': 'application/json',
                'Cache-Control': forceSync ? 'no-cache' : 'max-age=300' 
            },
            mode: 'cors',
            signal: AbortSignal.timeout(CONFIG.TIMEOUT)
        });
        
        if (response.ok) {
            const serverUsers = await response.json();
            console.log('✅ Direct quantum network data received:', serverUsers.length, 'entities');
            
            // Merge users
            const userList = Array.isArray(serverUsers) ? serverUsers : 
                           (serverUsers.users ? serverUsers.users : []);
            allUsers = [...new Set([...DEFAULT_USERS, ...userList, ...quantumUsers])];
            
            backendConnected = true;
            return true;
        }
    } catch (error) {
        console.log('❌ Direct backend load failed:', error.message);
    }
    
    // Strategy 2: Proxy attempts
    for (let i = 0; i < CONFIG.PROXY_URLS.length; i++) {
        try {
            console.log(`  🔄 Attempting load via proxy ${i + 1}...`);
            const proxyUrl = CONFIG.PROXY_URLS[i];
            const targetUrl = `${CONFIG.SERVER_URL}/users`;
            
            const fetchUrl = proxyUrl.includes('allorigins') ? 
                `${proxyUrl}${encodeURIComponent(targetUrl)}` : 
                `${proxyUrl}${targetUrl}`;
            
            const response = await fetch(fetchUrl, {
                method: 'GET',
                signal: AbortSignal.timeout(CONFIG.TIMEOUT)
            });
            
            if (response.ok) {
                let data = await response.json();
                
                // Handle allorigins response format
                if (data.contents) {
                    data = JSON.parse(data.contents);
                }
                
                const serverUsers = Array.isArray(data) ? data : (data.users || []);
                console.log(`✅ Proxy quantum load successful via proxy ${i + 1}:`, serverUsers.length, 'entities');
                
                allUsers = [...new Set([...DEFAULT_USERS, ...serverUsers, ...quantumUsers])];
                backendConnected = true;
                return true;
            }
        } catch (error) {
            console.log(`❌ Proxy ${i + 1} load error:`, error.message);
        }
    }
    
    console.log('⚠️ Quantum network unavailable, using local cache');
    allUsers = [...new Set([...DEFAULT_USERS, ...quantumUsers])];
    backendConnected = false;
    return false;
}

function resetSubmitButton() {
    submitBtn.disabled = false;
    submitBtn.innerHTML = '<span class="relative z-10">INJECT</span>';
    submitBtn.style.transform = 'scale(1)';
    submitBtn.style.background = '';
}

// Enhanced event listeners
submitBtn.addEventListener('click', () => {
    const username = usernameInput.value.trim();
    if (username && !submitBtn.disabled) {
        submitUser(username);
    }
});

usernameInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !submitBtn.disabled) {
        const username = usernameInput.value.trim();
        if (username) {
            submitUser(username);
        }
    }
});

// Real-time search with debouncing
let searchTimeout;
usernameInput.addEventListener('input', (e) => {
    const value = e.target.value.trim();
    
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => {
        if (value) {
            if (!isSearchMode) {
                isSearchMode = true;
                submitBtn.innerHTML = '<span class="relative z-10">🔍 SEARCH</span>';
            }
            performSearch(value);
        } else {
            if (isSearchMode) {
                isSearchMode = false;
                currentSearchTerm = '';
                filteredUsers = [];
                searchResults.style.opacity = '0';
                submitBtn.innerHTML = '<span class="relative z-10">INJECT</span>';
                usernameInput.placeholder = "Enter X handle...";
                displayPlasmaWall();
            }
        }
    }, 300);
});

// Enhanced input effects
usernameInput.addEventListener('focus', () => {
    const glow = usernameInput.nextElementSibling;
    if (glow) glow.style.opacity = '1';
    usernameInput.style.transform = 'scale(1.02)';
});

usernameInput.addEventListener('blur', () => {
    const glow = usernameInput.nextElementSibling;
    if (glow) glow.style.opacity = '0';
    usernameInput.style.transform = 'scale(1)';
});

// Real-time counter updates with better formatting
setInterval(() => {
    if (!currentSearchTerm) {
        const timestamp = new Date().toLocaleTimeString();
        const status = backendConnected ? 'SYNCED' : 'LOCAL';
        liveCounter.textContent = `⚡ Quantum Network: ${allUsers.length} active signatures [${status}] [${timestamp}] 🕊`;
    }
}, 8000);

// Enhanced initialization
async function initializeQuantumMatrix() {
    console.log('🌌 INITIALIZING ENHANCED QUANTUM PLASMA MATRIX...');
    console.log('🎵 Audio matrix detection: interstellar.mp3, interstellar.wav, music.mp3');
    console.log('👥 Default neural signatures loaded:', DEFAULT_USERS.length);
    console.log('🚀 Backend target:', CONFIG.SERVER_URL);
    console.log('🔄 CORS proxy fallbacks enabled:', CONFIG.PROXY_URLS.length);
    
    updateStatus('🌌 Quantum matrix initialization in progress...', 'info');
    
    // Initialize quantum network with backend sync
    const networkOnline = await loadFromBackend();
    
    // Display the enhanced plasma wall
    displayPlasmaWall();
    
    // Final initialization status
    console.log('✨ ENHANCED QUANTUM PLASMA MATRIX ONLINE');
    console.log(`🧬 Total consciousness signatures: ${allUsers.length}`);
    console.log(`📡 Backend status: ${networkOnline ? 'CONNECTED' : 'OFFLINE'}`);
    console.log(`💾 Local cache: ${quantumUsers.length} signatures`);
    
    // Set ready status
    setTimeout(() => {
        const statusText = networkOnline ? 
            '⚡ Quantum backend synchronized - matrix ready' : 
            '⚠️ Local quantum matrix ready - backend offline';
        updateStatus(statusText, networkOnline ? 'success' : 'warning');
    }, 2500);
}

// Enhanced auto-sync with better timing
setInterval(async () => {
    if (!syncInProgress && !isSearchMode) {
        console.log('🔄 Auto-sync quantum network...');
        const wasConnected = backendConnected;
        const success = await loadFromBackend();
        
        if (success && !wasConnected) {
            console.log('🎉 Backend connection restored!');
            updateStatus('🎉 Backend connection restored!', 'success');
            displayPlasmaWall();
        }
    }
}, 180000); // Every 3 minutes

// Enhanced error handling for failed connections
window.addEventListener('online', async () => {
    console.log('🌐 Network connectivity restored');
    updateStatus('🌐 Network restored - attempting backend sync...', 'info');
    await loadFromBackend(true);
    displayPlasmaWall();
});

// Start the enhanced quantum matrix
initializeQuantumMatrix();

// Add some debug info to console
console.log('🚀 PLASMA WALL DEBUG INFO:');
console.log('Backend URL:', CONFIG.SERVER_URL);
console.log('Proxy URLs:', CONFIG.PROXY_URLS);
console.log('Default Users:', DEFAULT_USERS);
</script>

</body>
</html>
