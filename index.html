<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Plasma Wall - Join the trillions club</title>
<script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="min-h-screen text-white overflow-hidden relative" style="background: linear-gradient(135deg, #0a0a0a, #1a3b2e, #0f2922, #1a3b2e, #0a0a0a);">

<!-- Enhanced Cosmic Background -->
<div class="absolute inset-0 overflow-hidden">
    <!-- Main spinning portal with multiple rings -->
    <div class="spinning-portal absolute inset-0 flex items-center justify-center">
        <div class="interstellar-ring-outer"></div>
        <div class="interstellar-ring-main"></div>
        <div class="interstellar-ring-inner"></div>
    </div>
    
    <!-- Dynamic energy particles -->
    <div class="energy-field absolute inset-0"></div>
    
    <!-- Floating plasma orbs -->
    <div class="plasma-orbs absolute inset-0">
        <div class="plasma-orb orb-1"></div>
        <div class="plasma-orb orb-2"></div>
        <div class="plasma-orb orb-3"></div>
        <div class="plasma-orb orb-4"></div>
        <div class="plasma-orb orb-5"></div>
        <div class="plasma-orb orb-6"></div>
    </div>
    
    <!-- Moving matrix grid -->
    <div class="matrix-grid absolute inset-0"></div>
    
    <!-- Scanning lines -->
    <div class="scan-lines absolute inset-0"></div>
</div>

<!-- Audio -->
<audio id="bgMusic" loop preload="auto" style="display: none;">
    <source src="./interstellar.mp3" type="audio/mpeg">
    <source src="./interstellar.wav" type="audio/wav">
    <source src="./music.mp3" type="audio/mpeg">
</audio>

<!-- Futuristic Header -->
<header class="relative z-10 text-center py-8">
    <h1 class="text-5xl font-bold text-white mb-2 cyber-glow animate-cyber-pulse">
        PLASMA HALL OF THE FAME 🕊
    </h1>
    <p class="text-xl text-green-300 font-medium matrix-text">
        Submit your X/Discord handle. Join the stable supercycle🕊
    </p>
    <div class="mt-2 text-sm text-green-400 pulse-fade" id="liveCounter">
        Loading quantum signatures...
    </div>
</header>

<!-- Enhanced Input Section -->
<div class="relative z-10 flex flex-col items-center justify-center px-4 mb-8">
    <div class="input-matrix flex items-center gap-4 max-w-5xl w-full">
        <div class="input-wrapper flex-1 relative">
            <input 
                type="text" 
                id="usernameInput" 
                placeholder="Enter X handle or Discord ID..." 
                class="w-full px-8 py-5 rounded-2xl text-white bg-black/60 border-2 border-green-500/50 focus:outline-none focus:border-green-400 focus:ring-2 focus:ring-green-400/30 text-lg backdrop-blur-lg transition-all duration-300"
                style="font-family: 'Courier New', monospace;"
            >
        </div>
        <button 
            id="submitBtn" 
            class="px-10 py-5 bg-gradient-to-r from-green-600 to-green-500 hover:from-green-500 hover:to-green-400 rounded-2xl font-bold text-lg cyber-button transform hover:scale-105 transition-all duration-300 shadow-lg"
        >
            <span class="relative z-10">INJECT</span>
        </button>
    </div>
    
    <div class="flex gap-4 mt-6">
        <button 
            id="musicToggle" 
            class="px-8 py-3 bg-gradient-to-r from-green-800 to-green-700 hover:from-green-700 hover:to-green-600 rounded-xl font-medium transition-all duration-300 cyber-button-small"
        >
            🎵 Play Music
        </button>
        <button 
            id="syncBtn" 
            class="px-8 py-3 bg-gradient-to-r from-blue-800 to-blue-700 hover:from-blue-700 hover:to-blue-600 rounded-xl font-medium transition-all duration-300 cyber-button-small"
        >
            🔄 Force Sync
        </button>
    </div>
    
    <div id="connectionStatus" class="mt-4 text-center text-green-300 status-text">
        Initializing quantum connection...
    </div>
</div>

<!-- Enhanced Plasma Wall Container -->
<div class="relative z-10 px-4 pb-8">
    <div class="plasma-container bg-black/50 backdrop-blur-xl rounded-3xl p-8 border-2 border-green-500/30 max-w-8xl mx-auto overflow-hidden shadow-2xl">
        <div id="userCount" class="text-center text-green-200 mb-8 text-xl font-semibold cyber-text">
            Scanning the matrix...
        </div>
        
        <!-- Enhanced Moving Wall with Multiple Rows -->
        <div class="plasma-wall-container relative h-[500px] overflow-hidden rounded-2xl border border-green-500/20">
            <!-- Row 1 - Moving Right -->
            <div class="wall-row row-1">
                <div id="movingWall1" class="plasma-wall"></div>
            </div>
            
            <!-- Row 2 - Moving Left -->
            <div class="wall-row row-2">
                <div id="movingWall2" class="plasma-wall reverse"></div>
            </div>
            
            <!-- Row 3 - Moving Right -->
            <div class="wall-row row-3">
                <div id="movingWall3" class="plasma-wall"></div>
            </div>
            
            <!-- Wall overlay effects -->
            <div class="wall-overlay absolute inset-0 pointer-events-none">
                <div class="scan-line absolute w-full h-1 bg-gradient-to-r from-transparent via-green-400 to-transparent opacity-60"></div>
            </div>
        </div>
        
        <div class="flex justify-between items-center mt-6 text-sm">
            <div class="text-green-400 matrix-signature">
                Neural Network: ACTIVE | X/Discord Support
            </div>
            <div class="text-green-400">
                Architect: @aabis | Enhanced
            </div>
        </div>
    </div>
</div>

<!-- Enhanced Cyberpunk Styles -->
<style>
/* Cyberpunk Color Palette */
:root {
    --neon-green: #00ff41;
    --dark-green: #22c55e;
    --matrix-green: #16a34a;
    --deep-green: #15803d;
    --cyber-black: #0a0a0a;
}

/* Enhanced Background Effects */
.spinning-portal {
    pointer-events: none;
}

.interstellar-ring-outer {
    width: 600px;
    height: 600px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    border: 3px solid transparent;
    border-radius: 50%;
    background: conic-gradient(
        from 0deg,
        transparent 0deg,
        var(--neon-green) 5deg,
        transparent 10deg,
        transparent 85deg,
        var(--dark-green) 90deg,
        transparent 95deg
    );
    animation: spinSlow 25s linear infinite;
    opacity: 0.4;
    mask: radial-gradient(circle, transparent 48%, white 50%, white 52%, transparent 54%);
}

.interstellar-ring-main {
    width: 400px;
    height: 400px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    border: 2px solid transparent;
    border-radius: 50%;
    background: conic-gradient(
        from 180deg,
        transparent 0deg,
        var(--dark-green) 15deg,
        transparent 30deg,
        var(--matrix-green) 180deg,
        transparent 195deg,
        transparent 330deg,
        var(--neon-green) 345deg,
        transparent 360deg
    );
    animation: spinMedium 15s linear infinite;
    opacity: 0.6;
    mask: radial-gradient(circle, transparent 35%, white 37%, white 65%, transparent 67%);
}

.interstellar-ring-inner {
    width: 200px;
    height: 200px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    border: 2px solid rgba(0, 255, 65, 0.5);
    border-radius: 50%;
    animation: spinFast 8s linear infinite reverse;
    box-shadow: 0 0 30px rgba(0, 255, 65, 0.3);
}

@keyframes spinSlow { from { transform: translate(-50%, -50%) rotate(0deg); } to { transform: translate(-50%, -50%) rotate(360deg); } }
@keyframes spinMedium { from { transform: translate(-50%, -50%) rotate(0deg); } to { transform: translate(-50%, -50%) rotate(360deg); } }
@keyframes spinFast { from { transform: translate(-50%, -50%) rotate(360deg); } to { transform: translate(-50%, -50%) rotate(0deg); } }

/* Dynamic Energy Field */
.energy-field {
    background: 
        radial-gradient(circle at 20% 30%, rgba(0, 255, 65, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 80% 70%, rgba(34, 197, 94, 0.12) 0%, transparent 50%),
        radial-gradient(circle at 50% 50%, rgba(22, 163, 74, 0.08) 0%, transparent 70%);
    animation: energyPulse 12s ease-in-out infinite;
}

@keyframes energyPulse {
    0%, 100% { opacity: 0.7; transform: scale(1); }
    50% { opacity: 1; transform: scale(1.05); }
}

/* Plasma Orbs */
.plasma-orb {
    position: absolute;
    border-radius: 50%;
    background: radial-gradient(circle, var(--neon-green), rgba(0, 255, 65, 0.3), transparent);
    filter: blur(1px);
    animation: plasmaDrift 15s ease-in-out infinite;
}

.orb-1 { width: 25px; height: 25px; top: 15%; left: 10%; animation-delay: 0s; }
.orb-2 { width: 20px; height: 20px; top: 25%; right: 15%; animation-delay: -3s; }
.orb-3 { width: 30px; height: 30px; bottom: 25%; left: 20%; animation-delay: -6s; }
.orb-4 { width: 18px; height: 18px; top: 60%; right: 25%; animation-delay: -9s; }
.orb-5 { width: 22px; height: 22px; bottom: 40%; right: 10%; animation-delay: -12s; }
.orb-6 { width: 28px; height: 28px; top: 40%; left: 5%; animation-delay: -15s; }

@keyframes plasmaDrift {
    0%, 100% { transform: translate(0, 0) scale(1); opacity: 0.6; }
    25% { transform: translate(30px, -40px) scale(1.2); opacity: 0.9; }
    50% { transform: translate(-20px, -80px) scale(0.8); opacity: 0.7; }
    75% { transform: translate(-40px, 30px) scale(1.1); opacity: 1; }
}

/* Matrix Grid */
.matrix-grid {
    background-image: 
        linear-gradient(rgba(0, 255, 65, 0.1) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0, 255, 65, 0.1) 1px, transparent 1px);
    background-size: 80px 80px;
    animation: gridFlow 30s linear infinite;
    opacity: 0.2;
}

@keyframes gridFlow {
    0% { transform: translate(0, 0); }
    100% { transform: translate(80px, 80px); }
}

/* Scanning Lines */
.scan-lines::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 2px;
    background: linear-gradient(90deg, transparent, var(--neon-green), transparent);
    animation: scanVertical 4s linear infinite;
}

@keyframes scanVertical {
    0% { transform: translateY(-2px); opacity: 1; }
    100% { transform: translateY(100vh); opacity: 0; }
}

/* Enhanced Typography */
.cyber-glow {
    text-shadow: 
        0 0 5px var(--neon-green),
        0 0 10px var(--neon-green),
        0 0 15px var(--neon-green),
        0 0 20px var(--dark-green);
}

@keyframes cyber-pulse {
    0%, 100% { 
        text-shadow: 
            0 0 5px var(--neon-green),
            0 0 10px var(--neon-green),
            0 0 15px var(--neon-green);
    }
    50% { 
        text-shadow: 
            0 0 10px var(--neon-green),
            0 0 20px var(--neon-green),
            0 0 30px var(--neon-green),
            0 0 40px var(--dark-green);
    }
}

.animate-cyber-pulse {
    animation: cyber-pulse 2s ease-in-out infinite;
}

/* Buttons */
.cyber-button {
    background: linear-gradient(135deg, var(--dark-green), var(--matrix-green));
    box-shadow: 
        0 0 20px rgba(0, 255, 65, 0.3),
        inset 0 0 20px rgba(0, 255, 65, 0.1);
    text-shadow: 0 0 8px rgba(0, 0, 0, 0.8);
    position: relative;
    overflow: hidden;
}

.cyber-button::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    animation: buttonShine 3s ease-in-out infinite;
}

@keyframes buttonShine {
    0% { left: -100%; }
    100% { left: 100%; }
}

/* Enhanced Wall Container */
.plasma-container {
    animation: containerRise 1.5s ease-out;
}

@keyframes containerRise {
    from { transform: translateY(50px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}

/* Multi-Row Wall System */
.plasma-wall-container {
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.6), rgba(0, 255, 65, 0.02));
    position: relative;
}

.wall-row {
    position: relative;
    height: 160px;
    overflow: hidden;
    border-bottom: 1px solid rgba(0, 255, 65, 0.1);
}

.wall-row:last-child {
    border-bottom: none;
}

.row-1 { }
.row-2 { }
.row-3 { }

.plasma-wall {
    display: flex;
    gap: 20px;
    position: absolute;
    animation: slideWall 40s linear infinite;
    padding: 10px;
}

.plasma-wall.reverse {
    animation: slideWallReverse 45s linear infinite;
}

@keyframes slideWall {
    0% { transform: translateX(0); }
    100% { transform: translateX(-50%); }
}

@keyframes slideWallReverse {
    0% { transform: translateX(-50%); }
    100% { transform: translateX(0); }
}

/* Enhanced Avatar Cards */
.avatar-card {
    flex-shrink: 0;
    width: 140px;
    height: 140px;
    position: relative;
    transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    cursor: pointer;
}

.avatar-card:hover {
    transform: scale(1.1) translateY(-5px);
    z-index: 20;
    filter: drop-shadow(0 0 25px rgba(0, 255, 65, 0.6));
}

.avatar-container {
    width: 100%;
    height: 100%;
    position: relative;
    border-radius: 20px;
    overflow: hidden;
    background: linear-gradient(135deg, var(--deep-green), var(--matrix-green));
    border: 3px solid var(--dark-green);
    box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
}

.avatar-img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
    background: linear-gradient(135deg, var(--deep-green), var(--matrix-green));
}

.avatar-loading {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(0, 255, 65, 0.1));
    animation: loadingPulse 1.5s ease-in-out infinite;
}

.avatar-loading::after {
    content: '⟡';
    font-size: 32px;
    color: var(--neon-green);
    animation: loadingSpin 1s linear infinite;
}

@keyframes loadingPulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

@keyframes loadingSpin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.avatar-fallback {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(135deg, var(--matrix-green), var(--deep-green));
    color: var(--neon-green);
    font-size: 48px;
    font-weight: bold;
    font-family: 'Courier New', monospace;
    text-shadow: 0 0 10px rgba(0, 255, 65, 0.8);
}

.handle-display {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(0, 255, 65, 0.1));
    color: var(--neon-green);
    text-align: center;
    padding: 6px 4px;
    font-size: 12px;
    font-weight: bold;
    font-family: 'Courier New', monospace;
    backdrop-filter: blur(10px);
    text-shadow: 0 0 5px rgba(0, 255, 65, 0.8);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.avatar-card:hover .handle-display {
    background: linear-gradient(135deg, rgba(0, 255, 65, 0.9), rgba(34, 197, 94, 0.8));
    color: var(--cyber-black);
    text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
}

/* Status styling */
.status-text {
    font-family: 'Courier New', monospace;
    text-shadow: 0 0 8px var(--dark-green);
}

/* Responsive Design */
@media (max-width: 768px) {
    .input-matrix {
        flex-direction: column;
        gap: 16px;
    }
    
    .avatar-card {
        width: 120px;
        height: 120px;
    }
    
    .wall-row {
        height: 140px;
    }
    
    .plasma-wall-container {
        height: 420px;
    }
}
</style>

<!-- Enhanced JavaScript -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    
// Configuration
const CONFIG = {
    SERVER_URL: 'http://162.250.191.81:4000',
    PROXY_URLS: [
        'https://api.allorigins.win/raw?url=',
        'https://cors-anywhere.herokuapp.com/'
    ],
    TIMEOUT: 5000,
    MAX_RETRIES: 3,
    RETRY_DELAY: 1000
};

const STORAGE_KEY = 'plasma_wall_quantum_users';

// DOM elements
const usernameInput = document.getElementById('usernameInput');
const submitBtn = document.getElementById('submitBtn');
const syncBtn = document.getElementById('syncBtn');
const bgMusic = document.getElementById('bgMusic');
const musicToggle = document.getElementById('musicToggle');
const connectionStatus = document.getElementById('connectionStatus');
const userCount = document.getElementById('userCount');
const liveCounter = document.getElementById('liveCounter');

let musicPlaying = false;
let syncInProgress = false;

// Default users
const DEFAULT_USERS = [
    'proofofnathan', 'scene999', 'MaxApoz', 'shadowofthefax',
    'primay_eth', 'kolyposts', 'CATTtwit', 
    'The9bo', 'happysubstack', 'techaddictif'
];

let allUsers = [...DEFAULT_USERS];

// Simplified Avatar System with working sources
function getWorkingAvatarUrl(username) {
    const isDiscordId = /^\d+$/.test(username);
    
    // Use UI Avatars as primary source - it always works
    const initial = username.charAt(0).toUpperCase();
    const bgColor = isDiscordId ? '5865F2' : '00ff41';
    const textColor = 'ffffff';
    
    // Primary avatar that always works
    const uiAvatarUrl = `https://ui-avatars.com/api/?name=${initial}&background=${bgColor}&color=${textColor}&size=200&bold=true&format=svg`;
    
    // Try DiceBear as secondary option (very reliable)
    const dicebearUrl = `https://api.dicebear.com/7.x/bottts/svg?seed=${username}&backgroundColor=${bgColor}`;
    
    // Return array of sources to try
    return [
        dicebearUrl,
        uiAvatarUrl // This will always work as fallback
    ];
}

// Create enhanced avatar card with immediate display
function createAvatarCard(username) {
    const card = document.createElement('div');
    card.className = 'avatar-card';
    
    const container = document.createElement('div');
    container.className = 'avatar-container';
    
    const img = document.createElement('img');
    img.className = 'avatar-img';
    img.alt = username;
    
    // Get avatar URLs
    const avatarUrls = getWorkingAvatarUrl(username);
    
    // Set the first URL directly (DiceBear usually works)
    img.src = avatarUrls[0];
    
    // If first fails, use fallback
    img.onerror = function() {
        this.onerror = null; // Prevent infinite loop
        this.src = avatarUrls[1]; // UI Avatars always works
    };
    
    container.appendChild(img);
    
    const overlay = document.createElement('div');
    overlay.className = 'handle-display';
    
    const isDiscordId = /^\d+$/.test(username);
    overlay.textContent = isDiscordId ? `Discord: ${username.slice(-6)}` : `@${username}`;
    
    card.appendChild(container);
    card.appendChild(overlay);
    
    // Add hover effect
    card.addEventListener('mouseenter', () => {
        card.style.transform = 'scale(1.1) translateY(-5px)';
    });
    
    card.addEventListener('mouseleave', () => {
        card.style.transform = 'scale(1) translateY(0)';
    });
    
    return card;
}

// Display plasma wall with multiple rows - SIMPLIFIED
function displayPlasmaWall() {
    console.log('Displaying', allUsers.length, 'users');
    
    // Get or create wall containers
    let wall1 = document.getElementById('movingWall1');
    let wall2 = document.getElementById('movingWall2');
    let wall3 = document.getElementById('movingWall3');
    
    // If walls don't exist, create them
    if (!wall1 || !wall2 || !wall3) {
        const container = document.querySelector('.plasma-wall-container');
        if (container) {
            container.innerHTML = `
                <div class="wall-row row-1">
                    <div id="movingWall1" class="plasma-wall"></div>
                </div>
                <div class="wall-row row-2">
                    <div id="movingWall2" class="plasma-wall reverse"></div>
                </div>
                <div class="wall-row row-3">
                    <div id="movingWall3" class="plasma-wall"></div>
                </div>
                <div class="wall-overlay absolute inset-0 pointer-events-none">
                    <div class="scan-line absolute w-full h-1 bg-gradient-to-r from-transparent via-green-400 to-transparent opacity-60"></div>
                </div>
            `;
            
            wall1 = document.getElementById('movingWall1');
            wall2 = document.getElementById('movingWall2');
            wall3 = document.getElementById('movingWall3');
        }
    }
    
    // Clear existing content
    if (wall1) wall1.innerHTML = '';
    if (wall2) wall2.innerHTML = '';
    if (wall3) wall3.innerHTML = '';
    
    // Shuffle users for variety
    const shuffled = [...allUsers].sort(() => Math.random() - 0.5);
    
    // Split users into 3 groups
    const groupSize = Math.ceil(allUsers.length / 3);
    const group1 = shuffled.slice(0, groupSize);
    const group2 = shuffled.slice(groupSize, groupSize * 2);
    const group3 = shuffled.slice(groupSize * 2);
    
    // Helper function to populate a wall
    const populateWall = (wall, users) => {
        if (!wall || !users.length) return;
        
        // Create two sets for seamless loop
        for (let set = 0; set < 2; set++) {
            users.forEach((username, index) => {
                const card = createAvatarCard(username);
                card.style.animationDelay = `${(set * users.length + index) * 0.05}s`;
                wall.appendChild(card);
            });
        }
    };
    
    // Populate each wall
    populateWall(wall1, group1.length ? group1 : allUsers);
    populateWall(wall2, group2.length ? group2 : allUsers);
    populateWall(wall3, group3.length ? group3 : allUsers);
    
    // Update counters
    userCount.textContent = `${allUsers.length} Neural Entities Active`;
    liveCounter.textContent = `Network: ${allUsers.length} signatures detected`;
}

// Storage functions
function saveUsersToStorage() {
    try {
        const userData = {
            users: allUsers.filter(user => !DEFAULT_USERS.includes(user)),
            timestamp: Date.now()
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(userData));
        console.log('💾 Saved', userData.users.length, 'users');
        return true;
    } catch (e) {
        console.error('Storage error:', e);
        return false;
    }
}

function loadUsersFromStorage() {
    try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
            const userData = JSON.parse(saved);
            const savedUsers = userData.users || userData;
            console.log('📦 Loaded', savedUsers.length, 'users');
            allUsers = [...new Set([...DEFAULT_USERS, ...savedUsers])];
            return savedUsers;
        }
    } catch (e) {
        console.error('Load error:', e);
    }
    return [];
}

// Music control
musicToggle.addEventListener('click', async () => {
    try {
        if (musicPlaying) { 
            bgMusic.pause(); 
            musicToggle.textContent = '🎵 Play Music'; 
            musicPlaying = false; 
        } else { 
            bgMusic.volume = 0.3;
            const playPromise = bgMusic.play();
            if (playPromise !== undefined) {
                playPromise.catch(e => console.log('Audio play failed:', e));
            }
            musicToggle.textContent = '🔇 Stop Music'; 
            musicPlaying = true; 
        }
    } catch(e) { 
        console.error('Audio error:', e);
        updateStatus('⚠️ Audio offline', 'warning');
    }
});

// Sync button
syncBtn.addEventListener('click', async () => {
    if (syncInProgress) return;
    
    syncInProgress = true;
    syncBtn.disabled = true;
    syncBtn.textContent = '🔄 Syncing...';
    
    updateStatus('🔄 Synchronizing with server...', 'info');
    
    const success = await loadFromBackend(true);
    displayPlasmaWall();
    
    setTimeout(() => {
        syncBtn.disabled = false;
        syncBtn.textContent = '🔄 Force Sync';
        syncInProgress = false;
        updateStatus(success ? '✅ Sync complete' : '⚠️ Using local data', success ? 'success' : 'warning');
    }, 2000);
});

// Status update with auto-clear
function updateStatus(message, type = 'info') {
    connectionStatus.textContent = message;
    connectionStatus.className = `mt-4 text-center status-text ${
        type === 'success' ? 'text-green-300' :
        type === 'warning' ? 'text-yellow-400' :
        type === 'error' ? 'text-red-400' :
        'text-green-300'
    }`;
    
    if (type !== 'error') {
        setTimeout(() => {
            connectionStatus.textContent = '⚡ System Ready';
            connectionStatus.className = 'mt-4 text-center status-text text-green-300';
        }, 5000);
    }
}

// Backend save with retry logic
async function saveToBackend(username) {
    console.log('Saving to backend:', username);
    
    for (let attempt = 0; attempt < CONFIG.MAX_RETRIES; attempt++) {
        try {
            // Try direct connection
            const response = await fetch(`${CONFIG.SERVER_URL}/users`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username }),
                mode: 'cors',
                signal: AbortSignal.timeout(CONFIG.TIMEOUT)
            });
            
            if (response.ok) {
                console.log('✅ Saved to server');
                return true;
            }
        } catch (e) {
            console.log(`Attempt ${attempt + 1} failed:`, e.message);
            
            // Try with proxy
            for (const proxy of CONFIG.PROXY_URLS) {
                try {
                    const url = `${proxy}${encodeURIComponent(CONFIG.SERVER_URL + '/users')}`;
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ username }),
                        signal: AbortSignal.timeout(CONFIG.TIMEOUT)
                    });
                    
                    if (response.ok) {
                        console.log('✅ Saved via proxy');
                        return true;
                    }
                } catch (err) {
                    console.log('Proxy failed:', err.message);
                }
            }
        }
        
        if (attempt < CONFIG.MAX_RETRIES - 1) {
            await new Promise(resolve => setTimeout(resolve, CONFIG.RETRY_DELAY));
        }
    }
    
    console.log('⚠️ Backend save failed, saved locally only');
    return false;
}

// Backend load with retry logic
async function loadFromBackend(forceSync = false) {
    console.log('Loading from backend...');
    
    for (let attempt = 0; attempt < CONFIG.MAX_RETRIES; attempt++) {
        try {
            // Try direct connection
            const response = await fetch(`${CONFIG.SERVER_URL}/users`, {
                method: 'GET',
                mode: 'cors',
                signal: AbortSignal.timeout(CONFIG.TIMEOUT)
            });
            
            if (response.ok) {
                const serverUsers = await response.json();
                console.log('✅ Loaded', serverUsers.length, 'users from server');
                
                const localUsers = loadUsersFromStorage();
                allUsers = [...new Set([...DEFAULT_USERS, ...serverUsers, ...localUsers])];
                
                saveUsersToStorage();
                return true;
            }
        } catch (e) {
            console.log(`Load attempt ${attempt + 1} failed:`, e.message);
            
            // Try with proxy
            for (const proxy of CONFIG.PROXY_URLS) {
                try {
                    const url = `${proxy}${encodeURIComponent(CONFIG.SERVER_URL + '/users')}`;
                    const response = await fetch(url, {
                        signal: AbortSignal.timeout(CONFIG.TIMEOUT)
                    });
                    
                    if (response.ok) {
                        const serverUsers = await response.json();
                        console.log('✅ Loaded via proxy');
                        
                        const localUsers = loadUsersFromStorage();
                        allUsers = [...new Set([...DEFAULT_USERS, ...serverUsers, ...localUsers])];
                        
                        saveUsersToStorage();
                        return true;
                    }
                } catch (err) {
                    console.log('Proxy failed:', err.message);
                }
            }
        }
        
        if (attempt < CONFIG.MAX_RETRIES - 1) {
            await new Promise(resolve => setTimeout(resolve, CONFIG.RETRY_DELAY));
        }
    }
    
    console.log('⚠️ Using local storage only');
    loadUsersFromStorage();
    return false;
}

// Submit user with validation
function submitUser() {
    const username = usernameInput.value.trim();
    
    if (!username) {
        updateStatus('❌ Please enter a username', 'error');
        usernameInput.focus();
        return;
    }
    
    // Clean the username
    const cleanUsername = username.replace('@', '').replace(/[^a-zA-Z0-9_]/g, '');
    
    if (cleanUsername.length < 2) {
        updateStatus('❌ Username too short (min 2 chars)', 'error');
        return;
    }
    
    if (cleanUsername.length > 30) {
        updateStatus('❌ Username too long (max 30 chars)', 'error');
        return;
    }
    
    if (allUsers.includes(cleanUsername)) {
        updateStatus('❌ User already exists!', 'error');
        return;
    }
    
    console.log('Adding user:', cleanUsername);
    
    // Disable button
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<span class="relative z-10">⟡ INJECTING...</span>';
    updateStatus('🧬 Injecting consciousness...', 'info');
    
    // Add to array
    allUsers.push(cleanUsername);
    
    // Save locally first
    if (!saveUsersToStorage()) {
        allUsers.pop();
        updateStatus('❌ Storage failed', 'error');
        resetSubmitButton();
        return;
    }
    
    // Update display immediately for better UX
    displayPlasmaWall();
    
    // Clear input
    usernameInput.value = '';
    
    // Try to save to backend (async)
    saveToBackend(cleanUsername).then(success => {
        if (success) {
            updateStatus('✅ User injected into the matrix!', 'success');
        } else {
            updateStatus('✅ User added (offline mode)', 'warning');
        }
    });
    
    // Reset button
    setTimeout(resetSubmitButton, 2000);
}

function resetSubmitButton() {
    submitBtn.disabled = false;
    submitBtn.innerHTML = '<span class="relative z-10">INJECT</span>';
}

// Event listeners
submitBtn.addEventListener('click', function(e) {
    e.preventDefault();
    submitUser();
});

usernameInput.addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        e.preventDefault();
        submitUser();
    }
});

// Live counter update
let counterInterval = setInterval(() => {
    const time = new Date().toLocaleTimeString();
    liveCounter.textContent = `Network: ${allUsers.length} signatures [${time}]`;
    
    // Add random glitch effect occasionally
    if (Math.random() > 0.8) {
        liveCounter.style.opacity = '0.5';
        setTimeout(() => {
            liveCounter.style.opacity = '1';
        }, 100);
    }
}, 5000);

// Auto-sync every 5 minutes
let syncInterval = setInterval(async () => {
    if (!syncInProgress) {
        console.log('Auto-sync triggered');
        await loadFromBackend();
        displayPlasmaWall();
    }
}, 300000);

// Initialize application
async function initialize() {
    console.log('🌌 PLASMA WALL INITIALIZING...');
    
    // Enable input
    usernameInput.disabled = false;
    usernameInput.readOnly = false;
    
    updateStatus('🌌 Quantum matrix initializing...', 'info');
    
    // Load saved users
    loadUsersFromStorage();
    
    // Try to sync with backend
    const backendAvailable = await loadFromBackend();
    
    // Display the wall
    displayPlasmaWall();
    
    // Set final status
    if (backendAvailable) {
        updateStatus('⚡ Connected to neural network', 'success');
    } else {
        updateStatus('⚡ Running in local mode', 'warning');
    }
    
    console.log('✨ PLASMA WALL READY');
}

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    clearInterval(counterInterval);
    clearInterval(syncInterval);
});

// Start the application
initialize();

}); // End DOMContentLoaded
